# 大厂算法笔试（不要有侥幸心理）

一，分析题目，理解题意。

二，一般化各种题目，尝试各种条件（边界条件）。

三，分析是使用高级数据结构还是，递归，动态规划。

四，分析题目，憋出递归。（遍历各种情况，不要总想着贪心，贪心是聪明的人的办法，递归尽量改成动态规划）

五，别管怎么变化，暴力循环一遍，（剔除不符合的条件）

六，自己首先把解题思路步骤弄清楚，程序才可以写出来

七，根据计算量思考解题方法

八，把情况分析完整。

# 不会算法题目知识总结

一，如果遇到圆环，可以尝试两倍数组实现圆环。

单调栈、最长回文子序列、三数之和、括号生成、下一个排列（字典序的下一个排列）、搜索旋转排序数组、

公式字符串求值

开始遍历进入递归过程，循环遇到右括号停止，左括号进行进一步的递归调用，乘除运算在往栈了压数的时候就进行运算，加减最后运算。

最大矩形问题

卡特兰数





# 动态规划（递归）心得

动态规划需要我们掌握动态规划问题设计状态的技巧（**无后效性**），并且需要知道如何推导状态转移方程，最后再去优化空间。

无后效性指为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。

换句话说：如果之前的阶段求解的子问题的结果包含了一些不确定的信息，导致了后面的阶段求解的子问题无法得到，或者很难得到，这叫「有后效性」，我们在当前这个问题第 1 次拆分的子问题就是「有后效性」的（大家可以再翻到上面再看看）；
解决「有后效性」的办法是固定住需要分类讨论的地方，记录下更多的结果。在代码层面上表现为：
状态数组增加维度，例如：「力扣」的股票系列问题；
把状态定义得更细致、准确，例如：前天推送的第 124 题：状态定义只解决路径来自左右子树的其中一个子树。

关键 1：理解题意

题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。

题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。

关键 2：如何定义子问题（如何定义状态）

设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。

友情提示：上面这句话大家姑且这么一看，脑子里有个印象，没有那么绝对。可能不同的人看会有不同的理解。如果我以后讲解的动态规划的设计思想与这里讲解的「设计状态思路」不一样的，我会再和大家说明。如果讲解有误导的地方，还请大家指出。，

我们 不知道和最大的连续子数组一定会选哪一个数，那么我们可以求出 所有 经过输入数组的某一个数的连续子数组的最大和。

例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题：

子问题 1：经过 -2−2 的连续子数组的最大和是多少；
子问题 2：经过 11 的连续子数组的最大和是多少；
子问题 3：经过 -3−3 的连续子数组的最大和是多少；
子问题 4：经过 44 的连续子数组的最大和是多少；
子问题 5：经过 -1−1 的连续子数组的最大和是多少；
子问题 6：经过 22 的连续子数组的最大和是多少；
子问题 7：经过 11 的连续子数组的最大和是多少；
子问题 8：经过 -5−5 的连续子数组的最大和是多少；
子问题 9：经过 44 的连续子数组的最大和是多少。
一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为 子问题的描述还有不确定的地方（这件事情叫做「有后效性」，我们在本文的最后会讲解什么是「无后效性」）。

例如「子问题 3」：经过 -3−3 的连续子数组的最大和是多少。

「经过 -3−3 的连续子数组」我们任意举出几个：

[-2,1,-3,4] ，-3−3 是这个连续子数组的第 3 个元素；
[1,-3,4,-1] ，-3−3 是这个连续子数组的第 2 个元素；
……
我们不确定的是：-3−3 是连续子数组的第几个元素。那么我们就把 -3−3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：

子问题 1：以 -2−2 结尾的连续子数组的最大和是多少；
子问题 2：以 11 结尾的连续子数组的最大和是多少；
子问题 3：以 -3−3 结尾的连续子数组的最大和是多少；
子问题 4：以 44 结尾的连续子数组的最大和是多少；
子问题 5：以 -1−1 结尾的连续子数组的最大和是多少；
子问题 6：以 22 结尾的连续子数组的最大和是多少；
子问题 7：以 11 结尾的连续子数组的最大和是多少；
子问题 8：以 -5−5 结尾的连续子数组的最大和是多少；
子问题 9：以 44 结尾的连续子数组的最大和是多少。
我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：

子问题 1：以 -2−2 结尾的连续子数组的最大和是多少；
以 -2−2 结尾的连续子数组是 [-2]，因此最大和就是 -2−2。

子问题 2：以 11 结尾的连续子数组的最大和是多少；
以 11 结尾的连续子数组有 [-2,1] 和 [1] ，其中 [-2,1] 就是在「子问题 1」的后面加上 1 得到。-2 + 1 = -1 < 1−2+1=−1<1 ，因此「子问题 2」 的答案是 1。

大家发现了吗，如果编号为 i 的子问题的结果是负数或者 00 ，那么编号为 i + 1 的子问题就可以把编号为 i 的子问题的结果舍弃掉（这里 i 为整数，最小值为 1 ，最大值为 8），这是因为：

一个数 a 加上负数的结果比 a 更小；
一个数 a 加上 00 的结果不会比 a 更大；
而子问题的定义必须以一个数结尾，因此如果子问题 i 的结果是负数或者 00，那么子问题 i + 1 的答案就是以 nums[i] 结尾的那个数。
因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。

接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。
